## 输入两个链表 ,找出他们的第一个公共结点。

## 思路

### 蛮力法
    碰到这道题的时候, 第一反应自然是蛮力法 
    在第一链表上顺序遍历每个结点 , 每遍历到第一个结点的时候 , 在第二个链表上顺序遍历每个结点。
    如果在第二个链表上有一个结点和第一个链表上的结点一样, 说明两个链表在这个结点上重合,
    于是就找到了他们的公共结点
    时间复杂度 O(m*n)

### 思考
    通常蛮力法不会是最好的方法 , 我们接下来试着分析有公共结点的两个链表有哪些特点。
    从链表结点的定义可以看出  , 这两个链表的是单向链表。
    如果两个单向链表有公共的结点 , 那么这两个链表从某个结点开始,
    他们的 next 都指向同一个结点。
    但由于是单向链表的结点,每个结点只有 next , 因此从第一个公共结点开始, 之后他们的所有结点都是
    重合的,不可能出现分叉。

    经过分析我们发现, 如果两个链表有公共结点,那么公共结点出现在两个链表的尾部。
    如果我们从两个链表的尾部开始向前比较, 最后一个相同的结点就是我们要找的结点。

    可问题是在单向链表中,我们只能从头结点开始按顺序遍历, 最后才能到达尾结点。
    最后到达的尾结点要最先被比较,这听起来是不是像栈的特点?

#### 解法1
    分别把两个链表的结点放入两个栈中, 这样两个链表的尾结点就位于两个栈的栈顶, 接下来比较两个栈顶的结点是否相同。
    如果相同, 则把栈顶弹出接着比较下一个栈顶, 直到找出最后一个相同的结点。

#### 解法2
    首先遍历两个链表得到他们的长度, 就能知道哪个链表比较长 , 以及长的链表比短的链表多几个结点。
    在第二次遍历的时候 , 在较长的链表上先走若干步, 接着再同时在两个链表上遍历, 找到的第一个相同的结点就是他们的第一个公共结点